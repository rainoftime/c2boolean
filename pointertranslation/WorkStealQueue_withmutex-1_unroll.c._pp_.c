# 1 "<stdin>"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "<stdin>"
# 1 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c"






# 1 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 1
# 1 "./preprocessor/ccpp-0.1/fake_include/_fake_defines.h" 1
# 2 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/_fake_typedefs.h" 1



typedef int _____STARTSTRIPPINGFROMHERE_____;

typedef int __cs_t;
typedef int __cs_attr_t;
typedef int __cs_mutex_t;
typedef int __cs_mutexattr_t;
typedef int __cs_cond_t;
typedef int __cs_condattr_t;
typedef int __cs_key_t;
typedef int __cs_once_t;
typedef int __cs_rwlock_t;
typedef int __cs_rwlockattr_t;
typedef int __cs_spinlock_t;
typedef int __cs_barrier_t;
typedef int __cs_barrierattr_t;

typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;

typedef int va_list;

typedef int fd_set;

typedef int _____STOPSTRIPPINGFROMHERE_____;
# 2 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 2
# 8 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/pthread.h" 1
# 9 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/stdlib.h" 1
# 10 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/unistd.h" 1
# 11 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/pthread.h" 1
# 12 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/assert.h" 1
# 13 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c" 2

typedef struct Obj
{
    int field;
} Obj;

void Init_ObjType(Obj *r)
{
    r->field = 0;
}

void Operation(Obj *r)
{
    r->field++;
}

void Check(Obj *r)
{
    assert(r->field == 1);
}







typedef struct WorkStealQueue
{
# 66 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c"
    pthread_mutex_t cs;

    long MaxSize;
    long InitialSize;

    long head;
    long tail;

    Obj** elems;
    long mask;

} WorkStealQueue;


long __VERIFIER_atomic_exchange(long *obj, long v)
{
    long t = *obj;
    *obj = v;
    return t;
}

_Bool __VERIFIER_atomic_compare_exchange_strong(long* obj, long* expected, long desired)
{
    if (*obj == *expected)
    {
        *obj = desired;
        return 1;
    }
    else
    {
        *expected = *obj;
        return 0;
    }
}

long readV(long *v) {
    long expected = 0;
    __VERIFIER_atomic_compare_exchange_strong(v, &expected, 0);
    return expected;
}

void writeV(long *v, long w) {
    __VERIFIER_atomic_exchange(v, w);
}


void Init_WorkStealQueue(WorkStealQueue* q, long size)
{
    q->MaxSize = 1024 * 1024;
    q->InitialSize = 1024;
    pthread_mutex_init(&q->cs, 0);
    writeV(&q->head, 0);
    q->mask = size - 1;
    writeV(&q->tail, 0);
    q->elems = malloc(size * sizeof(Obj*));
}

void Destroy_WorkStealQueue(WorkStealQueue *q)
{
    free(q->elems);
}
# 141 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c"
_Bool Steal(WorkStealQueue *q, Obj **result)
{
    _Bool found;
    pthread_mutex_lock(&q->cs);




    long h = readV(&q->head);
    writeV(&q->head, h + 1);



    if (h < readV(&q->tail)) {



        *result = q->elems[h & q->mask];
        found = 1;
    }
    else {


        writeV(&q->head, h);
        found = 0;
    }
    pthread_mutex_unlock(&q->cs);
    return found;
}

_Bool SyncPop(WorkStealQueue* q, Obj **result)
{
    _Bool found;

    pthread_mutex_lock(&q->cs);



    long t = readV(&q->tail) - 1;
    writeV(&q->tail, t);
    if (readV(&q->head) <= t)
    {


        *result = q->elems[t & q->mask];
        found = 1;
    }
    else
    {
        writeV(&q->tail, t + 1);
        found = 0;
    }
    if (readV(&q->head) > t)
    {


        writeV(&q->head, 0);
        writeV(&q->tail, 0);
        found = 0;
    }
    pthread_mutex_unlock(&q->cs);
    return found;
}

_Bool Pop(WorkStealQueue *q, Obj **result)
{


    long t = readV(&q->tail) - 1;
    writeV(&q->tail, t);



    if (readV(&q->head) <= t)
    {




        *result = q->elems[t & q->mask];
        return 1;
    }
    else
    {


        writeV(&q->tail, t + 1);
        return SyncPop(q, result);
    }
}

void SyncPush(WorkStealQueue *q, Obj* elem)
{
    pthread_mutex_lock(&q->cs);



    long h = readV(&q->head);
    long count = readV(&q->tail) - h;



    h = h & q->mask;
    writeV(&q->head, h);
    writeV(&q->tail, h + count);



    if (count >= q->mask)
    {


        long newsize = (q->mask == 0 ? q->InitialSize : 2 * (q->mask + 1));

        assert(newsize < q->MaxSize);

        Obj ** newtasks = malloc(newsize * sizeof(Obj*));
        long i;
        for (i = 0; i < count; i++)
        {
            newtasks[i] = q->elems[(h + i) & q->mask];
        }
        free(q->elems);
        q->elems = newtasks;
        q->mask = newsize - 1;
        writeV(&q->head, 0);
        writeV(&q->tail, count);
    }

    assert(count < q->mask);



    long t = readV(&q->tail);
    q->elems[t & q->mask] = elem;
    writeV(&q->tail, t + 1);
    pthread_mutex_unlock(&q->cs);
}


void Push(WorkStealQueue *q, Obj* elem)
{
    long t = readV(&q->tail);
# 296 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/WorkStealQueue_withmutex-1_unroll.c"
    if (t < readV(&q->head) + q->mask + 1 && t < q->MaxSize)




    {
        q->elems[t & q->mask] = elem;
        writeV(&q->tail, t + 1);
    }
    else
    {


        SyncPush(q, elem);
    }
}







void *Stealer(void *param)
{
    WorkStealQueue *q = (WorkStealQueue*) param;

    Obj *r;
    {
        if (Steal(q, &r))
        {
            Operation(r);

        }
    }
    {
        if (Steal(q, &r))
        {
            Operation(r);

        }
    }
    return 0;
}


int main(void)
{

    pthread_t handles[1];
    Obj *items = malloc(4*sizeof(Obj));



        Init_ObjType(&items[0]);

        Init_ObjType(&items[1]);

        Init_ObjType(&items[2]);

        Init_ObjType(&items[3]);



    WorkStealQueue q;

    Init_WorkStealQueue(&q, 2);



        pthread_create(&handles[0], 0, Stealer, &q);



    {
        Push(&q, &items[0]);
        Push(&q, &items[1]);
        Obj *r;
        if (Pop(&q, &r))
        {
            Operation(r);

        }
    }
    {
        Push(&q, &items[2]);
        Push(&q, &items[3]);
        Obj *r;
        if (Pop(&q, &r))
        {
            Operation(r);

        }
    }


    {
        Obj *r;
        if (Pop(&q, &r))
        {
            Operation(r);

        }
    }
    {
        Obj *r;
        if (Pop(&q, &r))
        {
            Operation(r);

        }
    }



        pthread_join(handles[0], 0);




        Check(&items[0]);

        Check(&items[1]);

        Check(&items[2]);

        Check(&items[3]);



    free(items);
    return 0;
}
