# 1 "<stdin>"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "<stdin>"
# 1 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c"
# 1 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 1
# 1 "./preprocessor/ccpp-0.1/fake_include/_fake_defines.h" 1
# 2 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/_fake_typedefs.h" 1



typedef int _____STARTSTRIPPINGFROMHERE_____;

typedef int __cs_t;
typedef int __cs_attr_t;
typedef int __cs_mutex_t;
typedef int __cs_mutexattr_t;
typedef int __cs_cond_t;
typedef int __cs_condattr_t;
typedef int __cs_key_t;
typedef int __cs_once_t;
typedef int __cs_rwlock_t;
typedef int __cs_rwlockattr_t;
typedef int __cs_spinlock_t;
typedef int __cs_barrier_t;
typedef int __cs_barrierattr_t;

typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;

typedef int va_list;

typedef int fd_set;

typedef int _____STOPSTRIPPINGFROMHERE_____;
# 2 "./preprocessor/ccpp-0.1/fake_include/stdio.h" 2
# 2 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/assert.h" 1
# 3 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/stdint.h" 1
# 4 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/stdlib.h" 1
# 5 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/pthread.h" 1
# 6 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/stdbool.h" 1
# 7 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 1 "./preprocessor/ccpp-0.1/fake_include/time.h" 1
# 8 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c" 2
# 27 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c"
int __VERIFIER_atomic_cas( uintptr_t* value, uintptr_t comp_val, uintptr_t new_val )
{

 if(comp_val == *value)
 {
  *value = new_val;
  return 1;
 }
 else
 {
  return 0;
 }

}




extern int nondet_int();
# 54 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c"
typedef struct Elem
{
 int data;
 struct Elem *next;
} elem;

void insert(elem *pointer, int data)
{

 while (pointer->next != 0)
 {
  pointer = pointer -> next;
 }

 pointer->next = (elem *)malloc(sizeof(elem));
 pointer = pointer->next;
 pointer->data = data;
 pointer->next = 0;
}

int finding(elem *pointer, int key)
{
 pointer = pointer -> next;

 pointer = pointer -> next;
 while (pointer != 0)
 {
  if (pointer->data == key)
  {
   return 1;
  }
  pointer = pointer -> next;
 }

 return 0;
}

void delete(elem *pointer, int data)
{


 while (pointer->next != 0 && (pointer->next)->data != data)
 {
  pointer = pointer -> next;
 }
 if (pointer->next == 0)
 {

  return;
 }

 elem *temp;
 temp = pointer -> next;

 pointer->next = temp->next;

 free(temp);



 return;
}

void print(elem *pointer)
{
 pointer = pointer->next;
 printf("thread %u: Print Sequential\n", (unsigned int) pthread_self());
 while (pointer != 0) {
  printf("%d ", pointer->data);
  pointer = pointer->next;
 }
 printf("\n");
 return;
}

void create(elem **head)
{
 (*head) = malloc(sizeof(elem));
 (*head)->next = 0;
}



struct node {
 int key;
 struct node * next;
};

typedef struct node Node;


static const bool __VERIFIER_atomic_is_marked_reference(const uintptr_t p)
{
 return p & 0x1;
}

static const uintptr_t __VERIFIER_atomic_get_unmarked_reference(const uintptr_t p)
{
 return p & 0xFFFFFFFE;
}

static const uintptr_t __VERIFIER_atomic_get_marked_reference(const uintptr_t p)
{
 return p | 0x1;
}




void Create_Linked_list(Node **head, Node **tail)
{

 (*head) = malloc(sizeof(Node));
 (**head).key = 0;
 (*tail) = malloc(sizeof(Node));
 (**tail).key = 100000;
 (*head)->next = (*tail);
}





static Node *search(Node *head, Node *tail, Node **left_node, int key) {

 Node *left_node_next = 0, *right_node = 0;




 do {
  Node *t = head;

  Node *t_next = head->next;


  do {
   if (!__VERIFIER_atomic_is_marked_reference((uintptr_t) t_next)) {
    (*left_node) = t;
    left_node_next = t_next;
   }
   t = (Node*) __VERIFIER_atomic_get_unmarked_reference((uintptr_t) t->next);
   if (t == tail) {
    break;
   }
   t_next = t->next;
  } while (__VERIFIER_atomic_is_marked_reference((uintptr_t) t_next) || (t->key < key));

  right_node = t;


  if (left_node_next == right_node) {
   if ((right_node != tail) && __VERIFIER_atomic_is_marked_reference((uintptr_t) right_node->next)) {

    continue;
   }
   else {
    return right_node;
   }
  }


  if (__VERIFIER_atomic_cas((uintptr_t*) (*left_node)->next, *(uintptr_t*) left_node_next, *(uintptr_t*) right_node)) {
   if ((right_node != tail) && __VERIFIER_atomic_is_marked_reference((uintptr_t) right_node->next))

    continue;
   else {
    return right_node;
   }
  }
 } while (1);

 return 0;
}




bool Insert_Element_With_Index(Node *head, Node *tail, int new_key) {
 Node *new_node = malloc(sizeof(Node));
 Node *right_node, *left_node;

 new_node->key = new_key;



 do {
  right_node = search(head, tail, &left_node, new_key);

  if ((right_node != tail) && (right_node->key == new_key)) {
   return 0;
  }

  new_node->next = right_node;

  if (__VERIFIER_atomic_cas(((uintptr_t*) &left_node->next), (uintptr_t) right_node, (uintptr_t) new_node )) {
   return 1;
  }
 } while (1);

 return 1;
}

bool Remove_Element_With_Index(Node *head, Node *tail, int search_key) {

 Node *right_node, *right_node_next, *left_node;



 do {

  right_node = search(head, tail, &left_node, search_key);

  if ((right_node == tail) && (right_node->key != search_key))
   return 0;
  right_node_next = right_node->next;

  if (!__VERIFIER_atomic_is_marked_reference((uintptr_t) right_node_next)) {
   if (__VERIFIER_atomic_cas((uintptr_t*) &right_node->next, (uintptr_t) right_node_next, __VERIFIER_atomic_get_marked_reference(*(uintptr_t*) right_node_next))) {

    break;
   }

  }
 } while (1);

 if (!(__VERIFIER_atomic_cas((uintptr_t*) &left_node->next, (uintptr_t) right_node, (uintptr_t) right_node_next))) {
  right_node = search(head, tail, &left_node, search_key);

 }
 return 1;
}

bool find(Node *head, Node *tail, int search_key) {
 Node *right_node, *left_node;

 right_node = search(head, tail, &left_node, search_key);

 if ((right_node == tail) || right_node->key != search_key)
  return 0;
 else
  return 1;
}

void print_list(Node *head, Node *tail)
{
 Node *current_node;

 printf("thread %u: Print Function\n", (unsigned int) pthread_self());
 printf("[");

 for (current_node = head->next; current_node != tail; current_node = current_node->next) {

  if (__VERIFIER_atomic_is_marked_reference((uintptr_t) current_node))
   continue;
  printf(" %d ", current_node->key);
 }
 printf("]\n");
}

extern bool nondet_bool();
# 330 "/home/trucnguyenlam/Development/cseq/regression/pointertranslation/nonblockinglinkedlist.c"
static Node *list_head;
static Node *list_tail;
static elem *start;

void *worker(void *arg)
{
 int i = 0;
 int aux = 0;
 for (i = 0; i < 2; ++i) {

  if (nondet_bool())
  {

   aux = nondet_int();

   if (Insert_Element_With_Index(list_head, list_tail, aux))
   {

    insert(start, aux);

   }
  }
  else
  {

   aux = nondet_int();

   if (find(list_head, list_tail, aux))
   {
    if (Remove_Element_With_Index(list_head, list_tail, aux))
    {

     delete(start, aux);

    }




   }
  }




 }
 return 0;
}

int main(void) {
 int i;
 pthread_t t[2];


 create(&start);
 Create_Linked_list(&list_head, &list_tail);


 for (i = 0; i < 2; ++i)
 {
  pthread_create(&(t[i]), 0, worker, 0);
 }

 for (i = 0; i < 2; ++i)
 {
  pthread_join(t[i], 0);
 }







 return 0;
}
